// Этот файл содержит крошечный набор правил распознавания синтаксиса
// в русских предложениях. Он предназначен для начального ознакомления
// с программированием структурного синтаксического анализатора проекта Solarix.
// Вы можете использовать его в качестве основы для разработки собственных наборов правил
// без каких-либо ограничений.
//
// Подробное описание синтаксиса правил парсера - на странице
// http://www.solarix.ru/for_developers/docs/rules.shtml
//
// Отладка правил с помощью консольного отладчика описана на странице
// http://www.solarix.ru/for_developers/exercise/syntax-analysis.shtml



// Правило распознавания формы прилагательного - единственное число, мужской род, именительный падеж.
recognition ПервыйИм1 language=Russian
{
 if ".+ЫЙ" then ПРИЛАГАТЕЛЬНОЕ:"???" { СТЕПЕНЬ:АТРИБ ~КРАТКИЙ ЧИСЛО:ЕД ПАДЕЖ:ИМ РОД:МУЖ }
} 



// ------------------------------------------------------------------------
// Объявляем именованные группы правил заранее, чтобы можно было
// рекурсивно ссылаться друг на друга.


// Группа прилагательного. В русском языке может выступать как
// в атрибутивной роли, так и в качестве части предиката.
patterns AdjPhrase { language=Russian } export
                                              {
                                               node:root_node
                                               ПАДЕЖ
                                               РОД
                                               ЧИСЛО
                                               ОДУШ
                                               КРАТКИЙ
                                              }

// Группа инфинитива.
patterns InfPhrase { language=Russian } export { node:root_node }


// Группа существительного.
patterns NounPhrase { language=Russian } export { node:root_node РОД ПАДЕЖ ЧИСЛО ОДУШ }


// Прямое дополнение для глаголов, деепричастий и причастий.
// Мы будем учитывать не просто переходность глаголов, а более точное
// грамматическое свойство - падежную валентность, поэтому объявляем
// падеж в списке экспорта.
patterns DirectObj { language=Russian } export { node:root_node ПАДЕЖ }

// Сказуемое - это либо глагол, либо прилагательное плюс глагол-связка.
// Могут быть и другие варианты предикатов, но мы ограничимся этими двумя.
patterns Predicate { language=Russian } export { node:root_node ЛИЦО ЧИСЛО РОД }

// Подлежащее. Будем рассматривать только два варианта - личное местоимение или существительное.
patterns Subject { language=Russian } export { node:root_node ЛИЦО ЧИСЛО РОД }


// Предложение - сочетание подлежащего и сказуемого.
patterns Clause { language=Russian } export { node:root_node }


// ----------------- ДАЛЕЕ ИДУТ РЕАЛИЗАЦИИ ПРАВИЛ ---------------------


// Простейший вариант - одно прилагательное
pattern AdjPhrase
{
 прилагательное:*{} : export {
                              node:root_node
                              ПАДЕЖ
                              РОД
                              ЧИСЛО
                              ОДУШ
                              КРАТКИЙ
                             }
}


// Прилагательное с атрибутирующим наречием.
pattern AdjPhrase
{
 // Конструкция xxx=yyy позволяет задавать локальную переменную, на которую можно ссылаться
 // в некоторых случаях в рамках текущего правила. Смотрите, к примеру, секцию : links{} в самом конце.
 adv=наречие:*{ степень:атриб } // наречие должно быть в словарной форме (положительная степень)
 adj=прилагательное:*{} : export {
                                  node:root_node
                                  ПАДЕЖ
                                  РОД
                                  ЧИСЛО
                                  ОДУШ
                                  КРАТКИЙ
                                 }
} : links {
           adj.<ATTRIBUTE>adv // задаем ребро для синтаксического дерева - от прилагательного
                              // к наречию с заданным типом.
          }


// Одиночное существительное как простейший вариант группы.
pattern NounPhrase
{
 существительное:*{}:export { node:root_node ПАДЕЖ ЧИСЛО РОД ОДУШ }
}

// Существительное может атрибутироваться прилагательным.
// При этом мы должны проверить согласование по роду, падежу, числу и одушевленности для
// винительного падежа.
pattern NounPhrase
{
 adj=AdjPhrase
 n=существительное:*{
                     // Конструкция =xxx:yyy в этом месте, внутри секции уточнения для опорной точки,
                     // позволяет сопоставить значения координат у текущей опорной точки и у той,
                     // на которую ссылается переменная.
                     =adj:ЧИСЛО =adj:ПАДЕЖ =adj:РОД =adj:ОДУШ
                    } : export { node:root_node ПАДЕЖ ЧИСЛО РОД ОДУШ }
} : links { n.<ATTRIBUTE>adj }
           

// Более развернутый вариант - два атрибутирующих прилагательных для существительного.
pattern NounPhrase
{
 adj1=AdjPhrase
 adj2=AdjPhrase
 n=существительное:*{
                     // Проверим согласование для ОБОИХ прилагательных.
                     =adj1:ЧИСЛО =adj1:ПАДЕЖ =adj1:РОД =adj1:ОДУШ
                     =adj2:ЧИСЛО =adj2:ПАДЕЖ =adj2:РОД =adj2:ОДУШ
                    } : export { node:root_node ПАДЕЖ ЧИСЛО РОД ОДУШ }
} : links { n.{
               // Когда нужно задать два или более рёбер, выходящих из одного корня,
               // нужно просто перечислить их в фигурных скобках:
               <ATTRIBUTE>adj1
               <ATTRIBUTE>adj2
              } }



// А вот так можно реализовать распознавание не-словарных элементов в тексте.
// В качестве распознающей функции используем регулярное выражение.
// Разумеется, нужно проверять, что на выходе токенизатора (лексера) интересующая
// нас цепочка символов не была разбита на несколько слов.
// А.С.Пушкин
pattern NounPhrase export { node:root_node (РОД) (ПАДЕЖ) ЧИСЛО (ОДУШ) }
{
 @regex_strict("[\\@А\\@Б]\\.[\\@А\\@Б]\\.[\\@А\\@БЙ][\\@а\\@б\\@й]+"):export { node:root_node ЧИСЛО:ЕД }
}


// Группа существительного может выступать в роли прямого дополнения.
pattern DirectObj
{
 NounPhrase:export { node:root_node ПАДЕЖ } // Для проверки согласования с падежной
                                            // валентностью глагола-сказуемого, мы пробрасываем
                                            // наружу значение падежа из вызванного правила для
                                            // распознавания существительного.
}


// Личное местоимение в именительном падеже является подлежащим.
pattern Subject
{
 местоимение:*{
               падеж:им // явно требуем, чтобы местоимение было в именительном падеже.
              } : export { node:root_node ЛИЦО ЧИСЛО РОД }
}

// Существительное может выступать в роли подлежащего, если оно в именительном падеже.
// При этом такое подлежащее будет согласовываться с глагольным сказуемым
// как 3е лицо.
pattern Subject
{
 NounPhrase{ падеж:им } : export {
                                  node:root_node
                                  ЛИЦО:3 // мы экспортируем наружу явно заданное значение лица.
                                  ЧИСЛО
                                  РОД
                                 }
}

/*
pattern Predicate
{
 глагол:*{
          наклонение:изъяв // глаголы в императиве нам не нужны.
         } : export { node:root_node ЛИЦО РОД ЧИСЛО }
}
*/


// Одиночный глагол в качестве сказуемого ИЛИ глагол с прямым дополнением.
// Обратите внимание, что тут использована специальная функция @optional().
pattern Predicate
{
 v=глагол:*{
            наклонение:изъяв // глаголы в императиве нам не нужны.
           } : export { node:root_node ЛИЦО РОД ЧИСЛО }
 // Если есть прямое дополнение и оно согласуется с глаголом по падежной
 // валентности, то забираем его из входной цепочки себе.
 obj=@optional( DirectObj{ =v:ПАДЕЖ } )
} : links {
           // Так как переменная obj не всегда будет создана (такова природа функции @optional),
           // то мы должны позволить движку считать такую ситуацию корректной, иначе он
           // при построении графа будет ругаться на отсутствие переменной obj.
           // Символ ~ как раз сообщает о такой возможности.
           v.~<OBJECT>obj
          }


// Объявляем именованое подмножество словарных статей.
// На самом деле перечисленные в нем прилагательные имеют атрибут МОДАЛЬНЫЙ,
// так что прямой необходимости в использовании именованного множества нет, но
// в дидактических целях давайте сделаем так и посмотрим, как объявленное
// множество может быть использовано в опорных точках правил.
wordentry_set AdjWithInf=
{
 прилагательное:должный{},
 прилагательное:способный{}
}


// В качестве предиката будем распознавать конструкции типа:
//
// ОН ДОЛЖЕН ПОСПАТЬ
pattern Predicate export { node:root_node (ЛИЦО) ЧИСЛО РОД }
{
 // Упоминание имени ранее объявленного множества в опорной точке
 // создает проверку, что слово принадлежит одной из перечисленных словарных статей.
 // Мы также проверяем, что прилагательное находится в краткой форме.
 adj=AdjWithInf{ КРАТКИЙ } : export { node:root_node ЧИСЛО РОД }
 inf=InfPhrase
} : links { adj.<INFINITIVE>inf }



// Распознаем конструкцию с инфинитивом.
// Благодаря использованию функции @coalesce мы вместо двух правил имеем одно,
// работающее почти так же. Ранее мы уже использовали функцию @optional, которая
// является жадным вариантом @coalesce.
pattern InfPhrase
{
 inf=инфинитив:*{}:export { node:root_node }
 // Если после инфинитива идет прямое дополнение, согласующееся с глаголом по падежной
 // валентности, то забираем его себе, но также ветвим исполнение и запускаем второй вариант
 // дальнейшего распознавания, без фиксации на прямом дополнении.
 obj=@coalesce( DirectObj{ =inf:ПАДЕЖ } )
} : links { inf.~<OBJECT>obj }



// Именованное подмножество лексем. В данном случае это знаки
// препинания, которыми может ограничиваться предложение. Обратите
// внимание на отличие от именованного подмножества словарных статей AdjWithInf.
word_set ClauseTerminator=
{
 ',',
 '!',
 '?'
}

// Распознаём простейшее предложение, состоящее из подлежащего и сказуемого.
pattern Clause
{
 sbj=Subject
 p=Predicate { =sbj:ЛИЦО =sbj:ЧИСЛО =sbj:РОД } : export { node:root_node }
 fin=@optional(ClauseTerminator) // точка в конце предложения опциональна.
} : links {
           // так сложилось исторически, что сказуемое выступает в роли корневого узла в
           // синтаксическом дереве. Разумеется, можно изменить это правило и строить дерево из
           // подлежащего, что, кстати, снимет некоторые сложности с нулевой связкой.
           p.{
              <SUBJECT>sbj
              ~<PUNCTUATION>fin // если терминатор был опознан, то приткнем его к сказуемому.
             }
          }


pattern Clause
{
 sbj=NounPhrase
 copula='-' : export { node:root_node }
 rhema=NounPhrase
} : links
{
 copula.{
         <SUBJECT>sbj
         <RHEMA>rhema
        }
}


// -------------------------------------------------------------------------
// Все, правила для распознавания элементов фразы заданы.
// Теперь пишем правила верхнего уровня. Они безымянные, что отличает их
// от остальных. Они вызываются в самом начале анализа и организуют
// процесс распознавания синтаксиса.
// В нашем случае все очень просто - вызываем правила для распознавания
// простого предложения "подлежащее+сказумое".
pattern language=Russian
{
 beth:begin{} // специальная нетерминальная метка для начала предложения.
 Clause
 beth:end{} // метка конца предложения.
}

